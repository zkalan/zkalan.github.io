<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>麻绳先生</title>
  
  <subtitle>做一些记录性的工作</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zkalan.com/"/>
  <updated>2019-12-26T06:53:21.784Z</updated>
  <id>http://zkalan.com/</id>
  
  <author>
    <name>Zhang Kai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaCV初步使用之rtmp推流和在线播放</title>
    <link href="http://zkalan.com/javaCV%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8%E4%B9%8Brtmp%E6%8E%A8%E6%B5%81%E5%92%8C%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE.html"/>
    <id>http://zkalan.com/javaCV初步使用之rtmp推流和在线播放.html</id>
    <published>2019-12-26T06:06:07.000Z</published>
    <updated>2019-12-26T06:53:21.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从设备获取视频流"><a href="#从设备获取视频流" class="headerlink" title="从设备获取视频流"></a>从设备获取视频流</h2><blockquote><p>参考链接<br><a href="https://blog.csdn.net/eguid_1/article/details/52678775" target="_blank" rel="noopener">https://blog.csdn.net/eguid_1/article/details/52678775</a></p></blockquote><p>这块内容主要是javaCV基本API的使用，代码非常简单，我将其写在了一个类中，位于<br>src/main/java/com/zkalan/capture下，然后再demo类中调用测试；需要注意的是，网<br>上的很多代码将画板canvas的销毁方式设置为EXIT_ON_CLOSE，这会导致java虚拟机直接<br>推出，资源无法释放。我认为正确的写法应该是DISPOSED_ON_CLOSE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);</span><br></pre></td></tr></table></figure><h2 id="搭建rtmp推流服务器"><a href="#搭建rtmp推流服务器" class="headerlink" title="搭建rtmp推流服务器"></a>搭建rtmp推流服务器</h2><p>通过nginx服务器和nginx-rtmp-module可以简单的搭建一个rtmp服务器，我将使用的nginx<br>编译版本放在了<a href="https://download.csdn.net/download/bucuo12345/12054279" target="_blank" rel="noopener">这里</a><br>，这是已经包含了nginx-rtmp-module的版本，使用非常简单，首先在配置文件，例如<br>nginx-win-rtmp.conf中，添加一段rtmp配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        chunk_size 4000;</span><br><span class="line">        #mylive就是直播项目名</span><br><span class="line">        application mylive &#123;</span><br><span class="line">             live on;</span><br><span class="line"> </span><br><span class="line">             # record first 1K of stream</span><br><span class="line">             record all;</span><br><span class="line">             record_path /tmp/av;</span><br><span class="line">             record_max_size 1K;</span><br><span class="line"> </span><br><span class="line">             # append current timestamp to each flv</span><br><span class="line">             record_unique on;</span><br><span class="line"> </span><br><span class="line">             # publish only from localhost</span><br><span class="line">             #allow publish 127.0.0.1;</span><br><span class="line">             #deny publish all;</span><br><span class="line"> </span><br><span class="line">             #allow play all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在命令行中启动nginx服务器，例如命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe -c conf\nginx-win-rtmp.conf</span><br></pre></td></tr></table></figure><p>最后，启动第一部分写好的demo程序，注意publish address应该是这样的格式<br>rtmp://localhost:port/mylive/，使用potplayer或者vlc访问该链接，测试推流是否成功。</p><h2 id="在网页播放rtmp流"><a href="#在网页播放rtmp流" class="headerlink" title="在网页播放rtmp流"></a>在网页播放rtmp流</h2><blockquote><p>参考链接<br><a href="https://blog.csdn.net/qq_30152271/article/details/84334734" target="_blank" rel="noopener">https://blog.csdn.net/qq_30152271/article/details/84334734</a></p></blockquote><p>操作起来很简单，就是创建一个静态网页，放到服务器目录下，启动任何一个静态服务器，例如<br>上文的nginx，访问该静态网页，只要地址填写正确，就可以观看推流内容了。</p><font color="#99CC00">然而需要注意的是，videojs虽然声称是一个html5播放器，但它的5.x版本播放rtmp流时依然需要flash支持，并且6.x及以后版本不支持rtmp播放，也许是为了真正的叫做“html5播放器”？</font><h2 id="Demo地址"><a href="#Demo地址" class="headerlink" title="Demo地址"></a>Demo地址</h2><p><a href="https://github.com/zkalan/javaCV-rtmp-demo" target="_blank" rel="noopener">javaCV-rtmp-demo</a></p><p>浏览器效果图</p><p><img src="https://wx4.sinaimg.cn/mw690/005OmCBrly1gaa4n8lli6j30hd0cf42n.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从设备获取视频流&quot;&gt;&lt;a href=&quot;#从设备获取视频流&quot; class=&quot;headerlink&quot; title=&quot;从设备获取视频流&quot;&gt;&lt;/a&gt;从设备获取视频流&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考链接&lt;br&gt;&lt;a href=&quot;https://blog.csd
      
    
    </summary>
    
    
      <category term="javaCV" scheme="http://zkalan.com/categories/javaCV/"/>
    
    
      <category term="rtmp" scheme="http://zkalan.com/tags/rtmp/"/>
    
      <category term="javacv" scheme="http://zkalan.com/tags/javacv/"/>
    
      <category term="nginx" scheme="http://zkalan.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis第一节</title>
    <link href="http://zkalan.com/Mybatis%E7%AC%AC%E4%B8%80%E8%8A%82.html"/>
    <id>http://zkalan.com/Mybatis第一节.html</id>
    <published>2019-12-16T13:49:09.000Z</published>
    <updated>2019-12-19T14:05:26.893Z</updated>
    
    <content type="html"><![CDATA[<p>持久层技术解决方案有JDBC技术、Sping中对JDBC的简单封装、Apache的DBUtils等，这些都不是框架技术，后两者只是工具类。Mybatis是一个持久层框架，使用ORM思想实现了结果集的封装。ORM就是把数据库表和实体类及其实体类的属性对应起来。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>创建maven工程并导入坐标；</li><li>创建实体类和dao的接口；</li><li>创建Mybatis的主配置文件SqlMapConfig.xml</li><li>创建映射配置文件；</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>在Mybatis中把持久层的接口名称和映射文件也叫做Mapper；</li><li>Mybatis的映射配置文件位置必须和dao接口的包结构相同；</li><li>映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名；</li><li>映射配置文件的操作配置，id属性的取值必须是dao接口的方法名；</li><li>遵守3、4和5，不需要自己写dao接口实现类；</li></ol><h2 id="Mybatis连接池"><a href="#Mybatis连接池" class="headerlink" title="Mybatis连接池"></a>Mybatis连接池</h2><p>提供了三种配置方式。<br>配置的位置：主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用哪种连接池。</p><ul><li>POOLED：采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现。</li><li>UNPOOLED：采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用赤的思想。</li><li>JNDI：采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器能拿到的DataSource不同。web和maven的war工程才可使用。tomcat服务器采用的连接池是dbcp连接池。</li></ul><h2 id="Mybatis中的事务"><a href="#Mybatis中的事务" class="headerlink" title="Mybatis中的事务"></a>Mybatis中的事务</h2><p>通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;持久层技术解决方案有JDBC技术、Sping中对JDBC的简单封装、Apache的DBUtils等，这些都不是框架技术，后两者只是工具类。Mybatis是一个持久层框架，使用ORM思想实现了结果集的封装。ORM就是把数据库表和实体类及其实体类的属性对应起来。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="mybatis" scheme="http://zkalan.com/categories/mybatis/"/>
    
    
      <category term="mybatis" scheme="http://zkalan.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC第一节</title>
    <link href="http://zkalan.com/SpringMVC%E7%AC%AC%E4%B8%80%E8%8A%82.html"/>
    <id>http://zkalan.com/SpringMVC第一节.html</id>
    <published>2019-12-10T09:08:49.000Z</published>
    <updated>2019-12-11T14:40:12.430Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级web框架，属于Spring FrameWork的后续产品，以及融合在Spring Web Flow里面。Spring框架提供了构建Web应用程序的全部功能MVC模块，使用Spring可插入的MVC框架，从而在进行Web开发时，选择使用Spring MVC框架或集成其他MVC开发框架，如Struts2等。支持RESTful编程风格的请求。</p><ul><li>清晰的角色划分；</li><li>分工明确，扩展灵活；</li><li>等</li></ul><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><h3 id="DispatcherServlet前端控制器"><a href="#DispatcherServlet前端控制器" class="headerlink" title="DispatcherServlet前端控制器"></a>DispatcherServlet前端控制器</h3><p>用户i请求到达前端控制器，相当于MVC模式中的C，DispatcherServlet是整个流程控制的中心，由它调用其他组件处理用户的请求，DispatcherServlet降低了组件之间的耦合。</p><h3 id="HandlerMapping处理器映射器"><a href="#HandlerMapping处理器映射器" class="headerlink" title="HandlerMapping处理器映射器*"></a>HandlerMapping处理器映射器*</h3><p>HandlerMapping负责根据用户请求找到Handler，SpingMVC提供了不同的映射器实现不同的映射方式，例如配置文件方式、实现接口方式、注解方式等。</p><h3 id="Handler处理器"><a href="#Handler处理器" class="headerlink" title="Handler处理器"></a>Handler处理器</h3><p>开发中需要编写的具体业务控制器，由DispatcherServlet把用户的请求转发到Handler，由Handler对具体的用户请求进行处理。</p><h3 id="HandlerAdapter处理器适配器"><a href="#HandlerAdapter处理器适配器" class="headerlink" title="HandlerAdapter处理器适配器*"></a>HandlerAdapter处理器适配器*</h3><p>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><h3 id="View-Resolver视图解析器"><a href="#View-Resolver视图解析器" class="headerlink" title="View Resolver视图解析器*"></a>View Resolver视图解析器*</h3><p>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p><h3 id="View视图"><a href="#View视图" class="headerlink" title="View视图"></a>View视图</h3><p>SpringMVC框架提供了很多的View视图类型的支持，包括jstlView, freemarkerView, pdfView等。最常用的是jsp。一般情况下需要通过页面标签或页面模板技术将模型数据通过页面展示给用户。</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以作用于类和方法，支持分级映射</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//别名path和value通用，用于指定url</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//public enum RequestMethod &#123;</span></span><br><span class="line">    <span class="comment">//GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//限定传递的请求参数</span></span><br><span class="line">String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于指定限制请求的头条件</span></span><br><span class="line">String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><p>支持简单数据类型、对象、列表等。@RequestMapping(param={username=””})</p><h2 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h2><ol><li>首先实现Converter接口；</li><li>在spring配置文件中配置自定义类型转换器；</li></ol><h2 id="Servlet原生API"><a href="#Servlet原生API" class="headerlink" title="Servlet原生API"></a>Servlet原生API</h2><p>HttpServletRequest、HttpServletResponse、HttpSession、ServletContext。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ol><li>@RequestParam</li><li>@RequestBody get方法不适用</li><li>@PathVariable RESTful风格 WebClient模拟发送请求</li><li>@RequestHeader</li><li>@CookieValue 获取cookie的值</li><li>@ModelAttribute</li><li>@SessionAttributes 用于多次执行控制器方法间的参数共享</li></ol><h2 id="ResponseBody相应json数据"><a href="#ResponseBody相应json数据" class="headerlink" title="ResponseBody相应json数据"></a>ResponseBody相应json数据</h2><p>DispatcherServlet会拦截所有资源，导致静态资源，如image、css、js等也会被拦截，解决方法就是需要配置静态资源不拦截。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级web框架，属于Spring FrameWork的后续产品，以及融合在Spring Web Flow里面。Spring框架提供了构建Web应用程序的全部功能MVC模块，使用Spring可插入的MV
      
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://zkalan.com/categories/SpringMVC/"/>
    
    
      <category term="SpringMVC" scheme="http://zkalan.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://zkalan.com/Docker.html"/>
    <id>http://zkalan.com/Docker.html</id>
    <published>2019-12-10T07:18:05.000Z</published>
    <updated>2019-12-10T08:38:26.107Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的应用容器引擎；支持将软件编译成一个镜像，然后在镜像中做好各种软件的配置工作，随后将镜像发不出去，其他使用者可以直接使用该镜像；运行中的这个镜像成为容器，其优点在于启动速度。</p><h2 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h2><h3 id="Docker主机Host"><a href="#Docker主机Host" class="headerlink" title="Docker主机Host"></a>Docker主机Host</h3><p>一个物理或虚拟的机器，用于执行Docker守护进程和容器；</p><h3 id="Docker镜像Images"><a href="#Docker镜像Images" class="headerlink" title="Docker镜像Images"></a>Docker镜像Images</h3><p>Docker镜像是用于创建Docker容器的模板；</p><h3 id="Docker容器Container"><a href="#Docker容器Container" class="headerlink" title="Docker容器Container"></a>Docker容器Container</h3><p>容器是独立运行的一个或一组应用；</p><h3 id="Docker客户端Client"><a href="#Docker客户端Client" class="headerlink" title="Docker客户端Client"></a>Docker客户端Client</h3><p>客户端通过命令行或者其他工具使用Docker API和Docker的守护进程通信；</p><h3 id="Docker仓库Registry"><a href="#Docker仓库Registry" class="headerlink" title="Docker仓库Registry"></a>Docker仓库Registry</h3><p>Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库，Docker Hub提供了庞大的镜像集合使用；</p><h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line">docker -v</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql #搜索mysql image</span><br><span class="line">docker pull mysql #拉取镜像</span><br><span class="line">docker images #查看镜像列表</span><br><span class="line">docker rmi images-id #移除镜像</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mymysql -d mysql:TAG #启动容器</span><br><span class="line">docker ps #查看运行中的容器</span><br><span class="line">docker ps -a #查看所有容器</span><br><span class="line">docker stop container-id #停止容器</span><br><span class="line">docker rm -a # 删除所有容器</span><br><span class="line">docker run --name container-name iamge-name -d -p 1008:8080 #-p进行端口映射</span><br><span class="line">docker logs container-id/container-name</span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker是一个开源的应用容器引擎；支持将软件编译成一个镜像，然后在镜像中做好各种软件的配置工作，随后将镜像发不出去，其他使用者可以直接使用该镜像；运行中的这个镜像成为容器，其优点在于启动速度。&lt;/p&gt;
&lt;h2 id=&quot;Docker核心概念&quot;&gt;&lt;a href=&quot;#Dock
      
    
    </summary>
    
    
      <category term="Docker" scheme="http://zkalan.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://zkalan.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot和web开发</title>
    <link href="http://zkalan.com/spring-boot%E5%92%8Cweb%E5%BC%80%E5%8F%91.html"/>
    <id>http://zkalan.com/spring-boot和web开发.html</id>
    <published>2019-12-06T13:33:07.000Z</published>
    <updated>2019-12-09T14:52:47.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h2><p>如何使用spring boot：</p><ol><li>创建spring boot应用，选中需要的模块；</li><li>spring boot已经默认将这些场景配置好，只需要在配置文件中指定少量配置就可与运行；</li><li>编写业务代码；</li></ol><p><em>自动配置原理</em></p><h2 id="webjars和静态资源映射规则"><a href="#webjars和静态资源映射规则" class="headerlink" title="webjars和静态资源映射规则"></a>webjars和静态资源映射规则</h2><ol><li><p>所有/webjars/**，都去classpath:/META-INF/resources/webjars查找资源；<br>webjars：以jar包方式引入静态资源。</p></li><li><p>“/**”访问当前项目的任何资源，静态资源文件夹</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"classpath:/MEAT-INF/resources/",</span><br><span class="line">"classpath:/resources/",</span><br><span class="line">"calsspath:/static/",</span><br><span class="line">"calsspath:/puclic/",</span><br><span class="line">"/":当前目录的根目录</span><br></pre></td></tr></table></figure></li><li><p>欢迎页：静态资源文件夹下的所有index.html页面，被”/**”映射；</p></li><li><p>所有的**/favicon.ico都是在静态资源文件夹下查找；</p></li></ol><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>JSP、</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h3><h4 id="导入语法空间"><a href="#导入语法空间" class="headerlink" title="导入语法空间"></a>导入语法空间</h4><h4 id="thymeleaf语法规则"><a href="#thymeleaf语法规则" class="headerlink" title="thymeleaf语法规则"></a>thymeleaf语法规则</h4><ul><li>片段包含：jsp:include<ul><li>th:insert</li><li>th:replace</li></ul></li><li>遍历:c:forEach<ul><li>th:each</li></ul></li><li>条件判断c:if<ul><li>th:if</li><li>th:unless</li><li>th:switch</li><li>th:case</li></ul></li><li>声明变量c:set<ul><li>th:object</li><li>th:with</li></ul></li><li>任意属性修改支持prepend,append<ul><li>th:attr</li><li>th:attrprepend</li><li>th:attrappend</li></ul></li><li>修改指定属性默认值<ul><li>th:value</li><li>th:href</li><li>th:src</li></ul></li><li>修改标签体内容<ul><li>th:text不转义</li><li>th:utext转义</li></ul></li><li>声明片段<ul><li>th:fragment</li></ul></li><li>…</li></ul><h4 id="thymeleaf表达式"><a href="#thymeleaf表达式" class="headerlink" title="thymeleaf表达式"></a>thymeleaf表达式</h4><ul><li>Simple expressions:<ul><li>Variable Expressions: ${…}</li><li>Selection Variable Expressions: *{…}</li><li>Message Expressions: #{…}</li><li>Link URL Expressions: @{…}</li><li>Fragment Expressions: ~{…}</li></ul></li><li>Literals<ul><li>Text literals: ‘one text’ , ‘Another one!’ ,…</li><li>Number literals: 0 , 34 , 3.0 , 12.3 ,…</li><li>Boolean literals: true , false</li><li>Null literal: null</li><li>Literal tokens: one , sometext , main ,…</li></ul></li><li>Text operations:<ul><li>String concatenation: +</li><li>Literal substitutions: |The name is ${name}|</li></ul></li><li>Arithmetic operations:<ul><li>Binary operators: + , - , * , / , %</li><li>Minus sign (unary operator): -</li></ul></li><li>Boolean operations:<ul><li>Binary operators: and , or</li><li>Boolean negation (unary operator): ! , not</li></ul></li><li>Comparisons and equality:<ul><li>Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</li><li>Equality operators: == , != ( eq , ne )</li></ul></li><li>Conditional operators:<ul><li>If-then: (if) ? (then)</li><li>If-then-else: (if) ? (then) : (else)</li><li>Default: (value) ?: (defaultvalue)</li></ul></li><li>Special tokens:<ul><li>No-Operation: _</li></ul></li></ul><h2 id="Spring-Boot自动配置Spring-MVC"><a href="#Spring-Boot自动配置Spring-MVC" class="headerlink" title="Spring Boot自动配置Spring MVC"></a>Spring Boot自动配置Spring MVC</h2><ul><li>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans;</li><li>Support for serving static resourcces, including support for Webjars;</li><li>Automatic registration of Converter, GenericConverter, Formatter beans;</li><li>Support for HttpMessageConerters;</li><li>Automatic registration of MessageCodeResolver;</li><li>Static index.html support;</li><li>Custom Favicon support;</li><li>Automatic use of a ConfigurableWebBindingInitializer bean;</li></ul><h3 id="修改Spring-Boot默认配置"><a href="#修改Spring-Boot默认配置" class="headerlink" title="修改Spring Boot默认配置"></a>修改Spring Boot默认配置</h3><h3 id="扩展Spring-MVC"><a href="#扩展Spring-MVC" class="headerlink" title="扩展Spring MVC"></a>扩展Spring MVC</h3><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>默认的区域信息是通过浏览器请求报文获取的。可以通过链接提交区域信息。<br>自己的信息解析器需要实现Localeresolver。</p><ol><li>编写国际化配置文件，抽取页面需要配置的国际化信息；</li><li>使用ResourceBundleMessageSource管理国际化资源信息；</li><li>在页面使用fml:message获取国际化内容；</li><li>可以自己编写区域信息解析器，替换Spring Boot默认的解析器ResourceBundleMessageSource；</li></ol><p><strong>模板引擎要实时生效，需要禁用模板缓存，页面修改要ctrl+F9重新编译</strong></p><h3 id="登陆状态检查需要拦截器"><a href="#登陆状态检查需要拦截器" class="headerlink" title="登陆状态检查需要拦截器"></a>登陆状态检查需要拦截器</h3><h3 id="thymeleaf公共页面元素抽取"><a href="#thymeleaf公共页面元素抽取" class="headerlink" title="thymeleaf公共页面元素抽取"></a>thymeleaf公共页面元素抽取</h3><ol><li>抽取公共片段<div th:fragment="copy"></div></li><li>引入公共片段<div th:insert="~{footer::copy}"></div></li><li>不同替换效果有th:insert、th:replace、th:include</li></ol><h3 id="错误处理的自动配置"><a href="#错误处理的自动配置" class="headerlink" title="错误处理的自动配置"></a>错误处理的自动配置</h3><p>可以参照ErrorMVCAutoConfiguration；容器中有如下组件：</p><ol><li>DefaultErrorAttributes</li><li>BasicErrorController</li><li>ErrorPageCustomizer</li><li>DefaultErrorViewResolver</li></ol><h2 id="注册Servlet、Filter、Linstener"><a href="#注册Servlet、Filter、Linstener" class="headerlink" title="注册Servlet、Filter、Linstener"></a>注册Servlet、Filter、Linstener</h2><p>Spring Boot默认是以jar包的方式启动嵌入式的Servlet容器来启动Spring Boot的web应用，没有web.xml文件；<br>注册三大组件使用ServletRegistrationBean, FilterRegistrationBean, ServletListenerRegistrationBean。</p><h3 id="其他嵌入式Servlet容器"><a href="#其他嵌入式Servlet容器" class="headerlink" title="其他嵌入式Servlet容器"></a>其他嵌入式Servlet容器</h3><h4 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h4><p>适合长连接</p><h4 id="Undertow"><a href="#Undertow" class="headerlink" title="Undertow"></a>Undertow</h4><p>后置处理器会获取所有容器中的定制器，以此配置Servlet容器，自己定义容器就是将自定义的定制器加到Bean工厂中。</p><h2 id="嵌入式Servlet容器启动原理"><a href="#嵌入式Servlet容器启动原理" class="headerlink" title="嵌入式Servlet容器启动原理"></a>嵌入式Servlet容器启动原理</h2><ol><li>Spring Boot应用启动运行run方法；</li><li>refreshContext(context);Spring Boot刷新IOC容器，创建IOC容器对象，并初始化容器，创建容器中的每一个组件，还判断了是否是web应用；</li><li>refresh(context);刷新刚才创建好的ioc容器；</li><li>onRefresh();web的IOC容器重写了onRefresh方法；</li><li>web IOC容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer();</li><li>获取嵌入式的Servlet容器工厂；TomcatEmbeddedServletContainerFactory创建对象，后置处理器随后获取所有的定制器来定制Servlet容器的相关配置；</li><li>使用容器工厂获取嵌入式的Servlet容器；</li><li>嵌入式的Servlet容器创建对象并启动Servlet容器；先启动嵌入式的Servlet容器，再将IOC容器中剩下的对象获取；</li></ol><h2 id="使用外置的Servlet容器"><a href="#使用外置的Servlet容器" class="headerlink" title="使用外置的Servlet容器"></a>使用外置的Servlet容器</h2><p>嵌入式Servlet容器优点在于简单、便携，缺点在于默认不支持JSP，优化定制不够复杂；使用定制器、自己编写嵌入式Servlet容器的创建工厂；</p><ol><li>必须创建一个war项目，利用idea创建目录结构；</li><li>将嵌入式的Tomcat指定为provided；</li><li>必须编写一个SpringBootServletInitializer的子类，并调用configure方法；</li><li>启动tomcat；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web开发&quot;&gt;&lt;a href=&quot;#web开发&quot; class=&quot;headerlink&quot; title=&quot;web开发&quot;&gt;&lt;/a&gt;web开发&lt;/h2&gt;&lt;p&gt;如何使用spring boot：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建spring boot应用，选中需要的模块；&lt;/li
      
    
    </summary>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/tags/spring-boot/"/>
    
      <category term="web开发" scheme="http://zkalan.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>YAML</title>
    <link href="http://zkalan.com/YAML.html"/>
    <id>http://zkalan.com/YAML.html</id>
    <published>2019-12-05T12:23:40.000Z</published>
    <updated>2019-12-05T13:20:18.543Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>YAML Ain’t Markup Language</strong></li><li><strong>YAML A Markup Language</strong></li></ol><p>.yml是YAML语言的文件，以数据为中心，比json、xml更适合做配置文件。</p><p>参考语法规范<a href="http://www.yaml.org" target="_blank" rel="noopener">http://www.yaml.org</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>key:(空格)value：表示一对键值对，空格是必须的；</p><p>以空格的缩进来控制层级关系，只要左对齐，就认为是同一层级。</p><h2 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h2><h3 id="字面值（普通的值，数字、字符串、布尔）"><a href="#字面值（普通的值，数字、字符串、布尔）" class="headerlink" title="字面值（普通的值，数字、字符串、布尔）"></a>字面值（普通的值，数字、字符串、布尔）</h3><p>key:(空格)value：字面直接写</p><ul><li>字符串默认不用引号</li><li>双引号和单引号有区别，前者会对特殊字符转义，后者只会当作普通字符</li></ul><h3 id="数组（list、set）"><a href="#数组（list、set）" class="headerlink" title="数组（list、set）"></a>数组（list、set）</h3><p>用-值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h3 id="对象、Map（属性和值）"><a href="#对象、Map（属性和值）" class="headerlink" title="对象、Map（属性和值）"></a>对象、Map（属性和值）</h3><p>方法和前文一致</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friend:</span></span><br><span class="line"><span class="attr">    firstname:</span> <span class="string">zhang</span></span><br><span class="line">    <span class="string">lastname：</span> <span class="string">san</span></span><br><span class="line"><span class="attr">    telphone:</span> <span class="number">136545646</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friend:</span> <span class="string">&#123;firstname:</span> <span class="string">zhang,lastname：</span> <span class="string">san,telphone:</span> <span class="number">136545646</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="解析yml配置文件"><a href="#解析yml配置文件" class="headerlink" title="解析yml配置文件"></a>解析yml配置文件</h2><p>spring-boot解析yml文件需要使用注解@ConfigurationProperties(prefix = “index-id””)</p><h3 id="ConfigurationProperties和value有区别"><a href="#ConfigurationProperties和value有区别" class="headerlink" title="ConfigurationProperties和value有区别"></a>ConfigurationProperties和value有区别</h3><p>默认从全局配置文件中获取值</p><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><p>解析非全局配置文件</p><p>@PropertySource(value = “calsspath:example.properties”)</p><h2 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h2><p>@ImportResource导入spring配置文件，使配置文件内容生效。</p><p>@ImportResource(location = “classpath:beans.xml”)</p><p>springboot推荐的像容器中添加组件的方式：<br>使用全注解的方式。<br>使用@Configuration指明一个配置类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;YAML Ain’t Markup Language&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;YAML A Markup Language&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;.yml是YAML语言的文件，以数据为中心，比j
      
    
    </summary>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/tags/spring-boot/"/>
    
      <category term="yaml" scheme="http://zkalan.com/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>gradle</title>
    <link href="http://zkalan.com/gradle.html"/>
    <id>http://zkalan.com/gradle.html</id>
    <published>2019-12-03T08:59:57.000Z</published>
    <updated>2019-12-05T03:17:34.327Z</updated>
    
    <content type="html"><![CDATA[<p>基于JVM的构建工具，有一些特性</p><ul><li>和maven一样基于约定优于配置的构建框架</li><li>强大的多工程构建支持</li><li>强大的依赖管理，基于apachelvy</li><li>支持已有的maven和ivy仓库</li><li>支持传递性依赖管理，不需要远程仓库或pom.xml等配置文件</li></ul><h2 id="gradle安装"><a href="#gradle安装" class="headerlink" title="gradle安装"></a>gradle安装</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>gradle需要1.5或更高版本的JDK；</li><li>gradle自带groovy库，忽略已安装grooy</li></ul><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul><li>将GRADLE_HOME/bin添加到PATH变量中</li><li>使用命令gradle -v命令测试</li></ul><h2 id="构建基础"><a href="#构建基础" class="headerlink" title="构建基础"></a>构建基础</h2><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><h2 id="groovy中的闭包"><a href="#groovy中的闭包" class="headerlink" title="groovy中的闭包"></a>groovy中的闭包</h2><p>就是一段代码块，在gradle中，主要将闭包作为参数使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个闭包</span></span><br><span class="line"><span class="keyword">def</span> bb = &#123;</span><br><span class="line">    println <span class="string">"hello, bb"</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个方法，方法的参数是闭包类型</span></span><br><span class="line"><span class="keyword">def</span> method(Closure closure)&#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用该方法</span></span><br><span class="line">method(bb)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个闭包，带参数</span></span><br><span class="line"><span class="keyword">def</span> closure2 = &#123;</span><br><span class="line">    v -&gt; println <span class="string">"hello, $&#123;v&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个需要闭包的方法</span></span><br><span class="line"><span class="keyword">def</span> method2(Closure closure)&#123;</span><br><span class="line">    closure(<span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method2(closure2)</span><br></pre></td></tr></table></figure><h2 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h2><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allproject&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于JVM的构建工具，有一些特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和maven一样基于约定优于配置的构建框架&lt;/li&gt;
&lt;li&gt;强大的多工程构建支持&lt;/li&gt;
&lt;li&gt;强大的依赖管理，基于apachelvy&lt;/li&gt;
&lt;li&gt;支持已有的maven和ivy仓库&lt;/li&gt;
&lt;li&gt;支
      
    
    </summary>
    
    
      <category term="gradle" scheme="http://zkalan.com/categories/gradle/"/>
    
    
      <category term="gradle" scheme="http://zkalan.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>maven</title>
    <link href="http://zkalan.com/maven.html"/>
    <id>http://zkalan.com/maven.html</id>
    <published>2019-12-02T13:28:29.000Z</published>
    <updated>2019-12-03T08:59:18.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><ol><li>一个项目就是一个工程<br>如果项目非常庞大，就不适用package来划分模块，最好每一个模块对应一个工程，利于分工协作。借助于maven就可以将一个项目拆分为多个工程。</li><li>项目中需要的jar包需要手动管理<br>同样的文件出现在不同的工程中，浪费存储，让文件结构冗余。</li><li>jar包来源复杂，难以维护</li><li>jar包依赖的其他文件仍需手动管理</li></ol><h2 id="什么是maven"><a href="#什么是maven" class="headerlink" title="什么是maven"></a>什么是maven</h2><p>是一款服务于java平台的自动化构建工具。</p><h2 id="什么是构建"><a href="#什么是构建" class="headerlink" title="什么是构建"></a>什么是构建</h2><p>以“java源文件”、“框架配置文件”、JSP、HTML、图片等资源为原材料产生一个可运行的项目的过程。</p><ul><li>清理：将之前编译生成的字节码文件删除，为下一次编译做准备</li><li>编译：将java源程序编程为class字节码文件</li><li>测试：自动测试，自动调用junit程序</li><li>报告：测试程序执行的结果</li><li>打包：动态web工程war包，java工程jar包</li><li>安装：maven特定的概念，将打包得到的文件复制到仓库中指定位置</li><li>部署：将动态web工程生成的war包复制到servlet容器的指定目录下</li></ul><h2 id="安装maven核心程序"><a href="#安装maven核心程序" class="headerlink" title="安装maven核心程序"></a>安装maven核心程序</h2><ul><li><strong>检查JAVA_HOME环境变量</strong></li><li>解压maven核心程序压缩包，英文无空格目录</li><li>配置maven相关环境变量<ul><li>MAVEN_HOME或M2_HOME（bin目录上一级）</li><li>path（通常带bin目录）</li></ul></li><li>运行mvn -v验证配置</li></ul><h2 id="maven核心概念"><a href="#maven核心概念" class="headerlink" title="maven核心概念"></a>maven核心概念</h2><h3 id="约定的目录"><a href="#约定的目录" class="headerlink" title="约定的目录"></a>约定的目录</h3><ul><li>根目录：工程名<ul><li>以配置的方式告诉框架自定义文件：<param-value>classpath:spring-content.xml</param-value></li></ul></li><li>src目录：存放源码</li><li>pom.xml：maven工程核心配置文件</li><li>main目录：存放主程序</li><li>test目录：存放测试程序</li><li>java目录：存放java源码</li><li>resources目录：存放框架或其他工具的配置文件</li></ul><p><em>约定大于配置，配置大于编码</em></p><h3 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h3><p>含义：project object model项目对象模型</p><h3 id="坐标（gav）"><a href="#坐标（gav）" class="headerlink" title="坐标（gav）"></a>坐标（gav）</h3><ul><li>groupid：公司组织域名倒序+项目名</li><li>artifactid：模块名</li><li>version：版本</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>对于自己的maven工程，使用install命令将其安装到仓库。</li><li>依赖的范围<ul><li>compile：对主程序有效，对测试程序有效，参与打包</li><li>test：对主程序无效，对测试程序有效，不参与打包</li><li>provided：对主程序有效，对测试程序有效，不参与打包，不参与部署，例如servlet-api.jar</li></ul></li><li>scope</li><li>只有compile范围的依赖可以传递</li><li>exclusions用于排除依赖</li></ul><p>依赖的原则</p><ul><li>作用：解决模块工程之间的jar包冲突<ul><li>最短路路径优先</li><li>路径相同时先声明者优先，指的是dependency标签的声明顺序</li></ul></li></ul><p>统一管理依赖的版本号</p><ul><li>properties标签，后跟依赖的id</li><li>通过${依赖的id}访问版本号</li><li>由于test范围的依赖不能传递，所以必然分散在各个模块工程中，导致不一致问题<ul><li>解决思路：将依赖统一提取到父工程中，在子工程中声明依赖时不指定版本，以父工程中统一的设定为准，方便维护</li></ul><ol><li>创建一个maven工程为父工程，注意打包方式为pom</li><li>在子工程中声明对父工程的引用</li><li>将子工程中的坐标中与父工程坐标中重复的内容删除</li><li>在父工程中统一管理依赖</li><li>子工程中删除依赖的版本号</li></ol></li></ul><p><strong>子工程要首先install父工程</strong></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><h3 id="生命周期-插件-目标"><a href="#生命周期-插件-目标" class="headerlink" title="生命周期/插件/目标"></a>生命周期/插件/目标</h3><ul><li>各个构建环节执行的顺序是既定的；</li><li>maven核心程序中定义了抽象的生命周期；</li><li>不论执行哪个命令，maven都会从生命周期最开始的位置执行；</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><em>一键安装各个模块工程</em><br>在一个总的聚合工程中配置各个参与聚合的模块</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用maven命令"><a href="#常用maven命令" class="headerlink" title="常用maven命令"></a>常用maven命令</h2><p><em>首先进入pom.xml目录</em></p><ul><li>mvn clean：清理</li><li>mvn compile：编译主程序</li><li>mvn test-compile：编译测试程序</li><li>mvn test：执行测试</li><li>mvn package：打包</li><li>mvn install：安装</li><li>mvn site：生成站点</li></ul><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>通过build标签配置当前工程的构建过程中的特殊设置，cargo插件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目前存在的问题&quot;&gt;&lt;a href=&quot;#目前存在的问题&quot; class=&quot;headerlink&quot; title=&quot;目前存在的问题&quot;&gt;&lt;/a&gt;目前存在的问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;一个项目就是一个工程&lt;br&gt;如果项目非常庞大，就不适用package来划分模块，最好每一
      
    
    </summary>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/tags/spring-boot/"/>
    
      <category term="入门" scheme="http://zkalan.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>spring boot入门</title>
    <link href="http://zkalan.com/spring-boot%E5%85%A5%E9%97%A8.html"/>
    <id>http://zkalan.com/spring-boot入门.html</id>
    <published>2019-12-02T09:08:16.000Z</published>
    <updated>2019-12-05T09:00:37.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring简介"><a href="#spring简介" class="headerlink" title="spring简介"></a>spring简介</h2><p>简化spring开发流程，J2EE开发的一站式解决方案。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>快速创建独立运行spring项目以及与主流框架集成</li><li>使用嵌入式servlet容器，应用无需达成war包</li><li>starters自动依赖与版本控制</li><li>大量的自动配置，简化开发，也可以修改默认值</li><li>无需配置XML，无代码生成</li><li>准生产环境的运行时应用监控</li><li>与云计算天然集成</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>是一种架构风格，其认为一个应用应该是一组小型服务，可以用过HTTP的方式通信。</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软件单元。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h2 id="spring-boot-starter"><a href="#spring-boot-starter" class="headerlink" title="spring-boot-starter"></a>spring-boot-starter</h2><p>启动器，spring-boot官方提供了一系列启动器。将所有的功能场景抽取出来，只要在项目里面引入这些starter，相关依赖就会自动导入。</p><h2 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>标注这是spring boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//spring应用启动</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//表示这是一个Spring Boot的配置类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span><span class="comment">//开启自动配置功能</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication</span><br></pre></td></tr></table></figure><p>@SpringBootConfiguration:表示这是一个Spring Boot的配置类；<br>@Configuration：配置类上，表示配置类也是容器中的一个组件@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span><span class="comment">//自动配置包</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br></pre></td></tr></table></figure><p>spring-boot的注释没事可以看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spring简介&quot;&gt;&lt;a href=&quot;#spring简介&quot; class=&quot;headerlink&quot; title=&quot;spring简介&quot;&gt;&lt;/a&gt;spring简介&lt;/h2&gt;&lt;p&gt;简化spring开发流程，J2EE开发的一站式解决方案。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://zkalan.com/tags/spring-boot/"/>
    
      <category term="入门" scheme="http://zkalan.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>spring的声明式事务控制</title>
    <link href="http://zkalan.com/spring%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6.html"/>
    <id>http://zkalan.com/spring的声明式事务控制.html</id>
    <published>2019-11-15T12:18:11.000Z</published>
    <updated>2019-11-18T13:29:41.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于XML的声明式事务控制"><a href="#基于XML的声明式事务控制" class="headerlink" title="基于XML的声明式事务控制"></a>基于XML的声明式事务控制</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置步骤--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tansactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的通知，此时需要导入事务的约束--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManger"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务的属性</span></span><br><span class="line"><span class="comment">        isolation：用于指定事务的隔离等级，默认是DEFAULT，表示使用数据库的默认隔离等级；</span></span><br><span class="line"><span class="comment">        propagation：用于指定事务的</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置AOP--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置AOP中的通用切入点表达式--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--建立食物通知和切入点表达式的对应关系--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的属性，在事物的通知tx:advice标签内--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcout</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">execution</span>(* <span class="attr">com.service.impl.</span>*<span class="attr">.</span>*(<span class="attr">..</span>))"&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--建立切入点表达式和事务通知的对应关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于纯注解的声明式事务控制"><a href="#基于纯注解的声明式事务控制" class="headerlink" title="基于纯注解的声明式事务控制"></a>基于纯注解的声明式事务控制</h2><ol><li>配置事务管理器；</li><li>开启spring对注解事务的支持；<ul><li>&lt;tx:annotation-driven transaction-manager=”transactionManager”&gt;</li></ul></li><li>在需要事物支持的地方使用@Transactional</li></ol><h2 id="基于编程式事务控制"><a href="#基于编程式事务控制" class="headerlink" title="基于编程式事务控制"></a>基于编程式事务控制</h2><p>不够灵活</p><h2 id="spring5新特性"><a href="#spring5新特性" class="headerlink" title="spring5新特性"></a>spring5新特性</h2><ul><li>与JDK相关升级；</li><li>核心容器更新；</li><li>JetBrains Kotlin语言支持；<ul><li>运行于在JVM上，独立语言；</li></ul></li><li>响应式编程风格；</li><li>Junit5支持；</li><li>依赖类库的更新；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基于XML的声明式事务控制&quot;&gt;&lt;a href=&quot;#基于XML的声明式事务控制&quot; class=&quot;headerlink&quot; title=&quot;基于XML的声明式事务控制&quot;&gt;&lt;/a&gt;基于XML的声明式事务控制&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="声明式事务控制" scheme="http://zkalan.com/tags/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring中的JdbctTemplate</title>
    <link href="http://zkalan.com/spring%E4%B8%AD%E7%9A%84JdbctTemplate.html"/>
    <id>http://zkalan.com/spring中的JdbctTemplate.html</id>
    <published>2019-11-14T12:50:49.000Z</published>
    <updated>2019-11-15T12:15:58.147Z</updated>
    
    <content type="html"><![CDATA[<p><strong>是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装，spring框架提供了许多操作模板类。</strong></p><ul><li>操作关系型数据<ul><li>JdbcTemplate</li><li>HibernateTemplate</li></ul></li><li>操作nosql数据库<ul><li>RedisTemplate</li></ul></li><li>操作消息队列<ul><li>JmsTemplate</li></ul></li></ul><h2 id="JdbcTemplate作用"><a href="#JdbcTemplate作用" class="headerlink" title="JdbcTemplate作用"></a>JdbcTemplate作用</h2><p>和数据库交互的模板类</p><h2 id="JdbcTemplate基本用法"><a href="#JdbcTemplate基本用法" class="headerlink" title="JdbcTemplate基本用法"></a>JdbcTemplate基本用法</h2><p>首先通过XML文件配置必要信息，这块是spring框架必要的IOC手法；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置JdbcTemplate--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/databasename"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取容器</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//获取对象</span></span><br><span class="line">JdbcTemplate jt = ac.getBean(<span class="string">"jdbcTemplate"</span>, JdbcTemplate.class);</span><br><span class="line"><span class="comment">//执行操作</span></span><br><span class="line">jt.execute(<span class="string">"insert into account(name, money) values ('name', 222)"</span>);</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">jt.update(<span class="string">"insert into account(name, money) values (?, ?)"</span>, <span class="string">"name"</span>, <span class="number">333</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line">jt.update(<span class="string">"update account set name=?, money=?, where id=?"</span>,<span class="string">"test"</span>,<span class="number">2345</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">jt.update(<span class="string">"delete from account where id=?"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//查询所有</span></span><br><span class="line">List&lt;Account&gt; accounts = jt.query(<span class="string">"select * from account where money &gt; ?"</span>, <span class="keyword">new</span> AccountRowMapper(), <span class="number">1000f</span>);</span><br><span class="line">List&lt;Account&gt; accounts = jt.query(<span class="string">"select * from account where money &gt; ?"</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class), <span class="number">1000f</span>);</span><br><span class="line"><span class="keyword">for</span>(Account account : accounts)&#123;</span><br><span class="line">    System.out.println(account);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询一个</span></span><br><span class="line">List&lt;Account&gt; accounts = jt.query(<span class="string">"select * from account where id = ?"</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class), <span class="number">1</span>);</span><br><span class="line"><span class="comment">//查询返回一行一列（使用聚合函数，但是不加group by子句</span></span><br><span class="line">Long count = jt.queryForObject(<span class="string">"select count(*) from account where money &gt; ?"</span>, Long.class, <span class="number">1000f</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;是spring框架中提供的一个对象，是对原始Jdbc API对象的简单封装，spring框架提供了许多操作模板类。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作关系型数据&lt;ul&gt;
&lt;li&gt;JdbcTemplate&lt;/li&gt;
&lt;li&gt;HibernateTe
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="JdbcTemplate" scheme="http://zkalan.com/tags/JdbcTemplate/"/>
    
  </entry>
  
  <entry>
    <title>spring基于XML的AOP</title>
    <link href="http://zkalan.com/spring%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP.html"/>
    <id>http://zkalan.com/spring基于XML的AOP.html</id>
    <published>2019-11-11T12:12:00.000Z</published>
    <updated>2019-11-14T12:07:52.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><ol><li>把通知bean也交给spring管理；</li><li>使用aop:config标签表明开始AOP配置；</li><li>使用aop:aspect标签表明配置切面；<ul><li>id属性：给切面提供一个唯一标识</li><li>ref属性：指定通知类bean的id</li></ul></li><li>在aop:aspect标签的内部使用对应标签配置通知的类型；<ul><li>aop:before：表示配置前置通知<ul><li>method：用于指定切面中哪个方法是前置通知；</li><li>pointcut：用于指定切入点表达式，该表达式的含义是指对业务层中哪些方法进行增强</li></ul></li><li>切入点表达式的写法：<ul><li>关键字：execution(表达式)</li><li>表达式：访问修饰符 返回值 类名.方法名(参数列表)<ul><li>访问修饰符可以省略</li><li>返回值可以使用通配符，表示任意返回类型</li><li>包名可以使用通配符，但包的层级需要和通配符一致</li><li>包名可以使用..表示包名及其子包</li><li>类名和方法名可以使用通配符</li><li>全通配写法：* *..*.*(..)</li></ul></li></ul></li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.service.impl.AccountServiceImpl&gt;&lt;/bean&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">    &lt;bean id="</span><span class="attr">logger</span>" <span class="attr">class</span>=<span class="string">"com.utils.Logger"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"logAdvice"</span> <span class="attr">ref</span>=<span class="string">"logger"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printlog"</span> <span class="attr">pointcut</span>=<span class="string">"execution(public void com.service.AccountServiceImpl.saveAccount())"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="四种常用通知类型"><a href="#四种常用通知类型" class="headerlink" title="四种常用通知类型"></a>四种常用通知类型</h2><ul><li>aop:before：前置通知，再切入点方法之前执行；</li><li>aop:after-returning：后置通知，在切入点方法正确执行之后执行，它和异常通知永远只有一个执行；</li><li>aop:after-throwing：异常通知，在切入点方法执行产生异常之后执行，它和后置通知永远只能执行一个；</li><li>aop:after：最终通知，无论切入点方法是否正确执行它都会在其后面执行；</li><li>aop:pointcut：配置切入点表达式，id属性用于指定表达式的唯一标识，expression属性用于指定表达式的内容；此标签写在aop:aspect内部时只能当前切面使用，将其写在aop:aspect外面时，所有前面可用；</li><li>aop:around：配置环绕通知；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置步骤&quot;&gt;&lt;a href=&quot;#配置步骤&quot; class=&quot;headerlink&quot; title=&quot;配置步骤&quot;&gt;&lt;/a&gt;配置步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;把通知bean也交给spring管理；&lt;/li&gt;
&lt;li&gt;使用aop:config标签表明开始AOP配置；&lt;/l
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="AOP" scheme="http://zkalan.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>特殊的日期</title>
    <link href="http://zkalan.com/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%97%A5%E6%9C%9F.html"/>
    <id>http://zkalan.com/特殊的日期.html</id>
    <published>2019-11-07T11:36:58.000Z</published>
    <updated>2019-11-07T11:41:55.987Z</updated>
    
    <content type="html"><![CDATA[<p>2019年11月7日，一个特殊的日子。会议和组织。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年11月7日，一个特殊的日子。会议和组织。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="特殊的日期" scheme="http://zkalan.com/tags/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%97%A5%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>AOP相关概念</title>
    <link href="http://zkalan.com/AOP%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html"/>
    <id>http://zkalan.com/AOP相关概念.html</id>
    <published>2019-11-06T03:13:52.000Z</published>
    <updated>2019-11-08T03:29:06.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>特点：字节码随用随创建，随用随加载<br>作用：不修改源码的基础上对方法增强<br>分类：基于接口的动态代理和基于子类的动态代理</p><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p>使用Proxy类中的newProxyInstance方法创建代理对象，<strong>被代理类至少实现一个接口，否则不能使用</strong>。newProxyInstance方法有三个参数，</p><ul><li>ClassLoader：用于加载代理对象字节码，和被代理对象使用相同的类加载器，固定写法；</li><li>Class[]：用于让代理对象和被代理对象有相同的方法，固定写法；</li><li>InvocationHandler：用于增强的代码，一般都是写一个接口的实现类，通常情况下是匿名内部类，但不是必须的，此接口的实现类都是谁用谁写；</li></ul><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><p>使用Enhancer类中的create方法，要求 被代理类不能是最终类。该create方法有两个参数，</p><ul><li>class：用于指定被代理对象的字节码</li><li>callback：用于提供增强代码</li></ul><h2 id="AOP-Aspect-Oriented-Programming"><a href="#AOP-Aspect-Oriented-Programming" class="headerlink" title="AOP(Aspect Oriented Programming)"></a>AOP(Aspect Oriented Programming)</h2><p>通过预编译方式和运行期动态代理实现程序功能的统一维护。是函数式编程的一种衍生范型。利用AOP可以对业务逻辑各个部分进行隔离，从而使业务逻辑各部分耦合度降低，提高程序可重用性，提高开发效率。</p><p>作用：在程序运行期间，不修改源码对已有方法进行增强；<br>优势：</p><ul><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul><p>实现方式：动态代理技术</p><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul><li>Joinpoint连接点：指那些被拦截到的点</li><li>Pointout切入点：要对哪些joinpoint进行拦截的定义，被增强的连接点成为切入点</li><li>Advice通知或增强：通知是指拦截到joinpoint之后所要做的事情就是通知。通知的类型有前置通知、后置通知、异常通知、最终通知、环绕通知。环绕通知中有明确的切入点方法调用。</li><li>Introduction引介：是一种特殊的通知在不修改类代码的前提下，introduction可以再运行期为类动态地添加一些方法或field</li><li>Target目标对象：代理的目标对象</li><li>Weaving织入：指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而aspectj采用编译期织入和类装载期织入。、</li><li>Proxy代理：一个类被AOP织入增强后，被产生一个结果代理类。</li><li>Aspect切面：是切入点和通知（引介）的结合</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态代理&quot;&gt;&lt;a href=&quot;#动态代理&quot; class=&quot;headerlink&quot; title=&quot;动态代理&quot;&gt;&lt;/a&gt;动态代理&lt;/h2&gt;&lt;p&gt;特点：字节码随用随创建，随用随加载&lt;br&gt;作用：不修改源码的基础上对方法增强&lt;br&gt;分类：基于接口的动态代理和基于子类的动态
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="AOP" scheme="http://zkalan.com/tags/AOP/"/>
    
      <category term="动态代理" scheme="http://zkalan.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>安装程序不支持配置安装通过usb或IEEE 1394端口链接的磁盘</title>
    <link href="http://zkalan.com/%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E4%B8%8D%E6%94%AF%E6%8C%81%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E9%80%9A%E8%BF%87usb%E6%88%96IEEE-1394%E7%AB%AF%E5%8F%A3%E9%93%BE%E6%8E%A5%E7%9A%84%E7%A3%81%E7%9B%98.html"/>
    <id>http://zkalan.com/安装程序不支持配置安装通过usb或IEEE-1394端口链接的磁盘.html</id>
    <published>2019-11-04T11:20:43.000Z</published>
    <updated>2019-11-04T11:31:06.285Z</updated>
    
    <content type="html"><![CDATA[<p>无意中得到一台外星人Alpha，不过并没有硬盘，于是拆了一个1T机械作为系统盘，这个机械硬盘只能通过USB的方式连接到电脑，所以也只能通过USB安装系统到硬盘，于是发生了上述错误“安装程序不支持配置安装通过usb或IEEE 1394端口链接的磁盘”，这个问题并没有找到太多解决办法，网上大多采用“windows to go”的解决办法，我试了一试，很方便，不过和安装介质有些关系，一开始的u盘总是出错，换成硬盘就好了。</p><p>参考链接：<a href="https://bbs.luobotou.org/thread-2427-1-1.html" target="_blank" rel="noopener">https://bbs.luobotou.org/thread-2427-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无意中得到一台外星人Alpha，不过并没有硬盘，于是拆了一个1T机械作为系统盘，这个机械硬盘只能通过USB的方式连接到电脑，所以也只能通过USB安装系统到硬盘，于是发生了上述错误“安装程序不支持配置安装通过usb或IEEE 1394端口链接的磁盘”，这个问题并没有找到太多解
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://zkalan.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="装系统" scheme="http://zkalan.com/tags/%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="windows to go" scheme="http://zkalan.com/tags/windows-to-go/"/>
    
  </entry>
  
  <entry>
    <title>spring整合junit</title>
    <link href="http://zkalan.com/spring%E6%95%B4%E5%90%88junit.html"/>
    <id>http://zkalan.com/spring整合junit.html</id>
    <published>2019-11-01T11:44:08.000Z</published>
    <updated>2019-11-01T12:09:52.306Z</updated>
    
    <content type="html"><![CDATA[<p>测试人员和开发人员关注的内容是不同的。例如junit测试人员并不会关注他将要测试的程序是否是由Spring框架搭建的，所以开发人员不应该期望测试程序能够存在对开发框架的依赖性代码。而Spring框架需要IOC核心容器，junit如何处理这个问题呢？</p><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><ol><li>导入spring整合junit的jar文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用junit提供的一个注解@RunWith把原有的main方法替换，替换为spring提供的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContentConfiguration</span>(classes = SpringConfiguration.class)</span><br></pre></td></tr></table></figure><ol start="3"><li>告知spring运行器，spring和ioc创建是基于文件还是注解，并说明位置信息</li></ol><p><strong>@ContextConfiguration</strong></p><ul><li>locations：指定xml文件的位置，加上classpath关键字，表示在类路径下</li><li>classes：指定注解类所在位置</li></ul><p><del>当Spring版本为5.x版本时，要求junit版本不低于4.12</del></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试人员和开发人员关注的内容是不同的。例如junit测试人员并不会关注他将要测试的程序是否是由Spring框架搭建的，所以开发人员不应该期望测试程序能够存在对开发框架的依赖性代码。而Spring框架需要IOC核心容器，junit如何处理这个问题呢？&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="junit" scheme="http://zkalan.com/tags/junit/"/>
    
  </entry>
  
  <entry>
    <title>spring中的注解二</title>
    <link href="http://zkalan.com/spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E4%BA%8C.html"/>
    <id>http://zkalan.com/spring中的注解二.html</id>
    <published>2019-11-01T10:27:48.000Z</published>
    <updated>2019-11-01T11:40:43.846Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="http://www.zkalan.com/spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3.html" target="_blank" rel="noopener">前文中的注解</a>能够对自己实现的类进行处理，但是对第三方的类则无法处理，只能使用XML的方式，为了解决这个问题，有必要提出新的注解。</strong></p><p>创建一个新类，它是一个配置作用的类，作用与applicationcontent.xml一致。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>作用：指定当前类是一个配置类<br>细节：当配置类作为AnnotationConfigApplicationContext对象创建时的参数时，该注解可以省略</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>作用：用于通过注解指定spring在创建容器时需要扫描的包路径<br>属性：value，它和basePackages的作用一致，都是用于指定创建容器时扫描的包路径，它替代了xml配置文件中的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.zkalan"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.zkalan"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfigurtaion</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>作用：用于把当前方法的返回值作为bean对象存入到spring中的ioc容器中<br>属性：name，用于指定bean的id，当不写时，默认值是当前方法的名字<br>细节：当我们使用注解配置方法时，如果方法有参数，spring矿建回去容器中查找有没有可用的bean对象，查找方式和@AutoWired注解一样</p><p><strong>使用纯注解方式时，使用AnnotationConfigApplicationContext方法获取容器对象。</strong></p><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>设置bean对象的实现模式，例如singleton、prototype</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>作用：用于导入其他的配置类<br>属性：value，用于指定其他配置类的字节码；有Import注解的类是父配置类，被import的是子配置类</p><h2 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:config.properties"</span>)</span><br></pre></td></tr></table></figure><p>在实际中，自己写的类使用注解更方便，第三方类使用XML配置更方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.zkalan.com/spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前文中的注解&lt;/a&gt;能够对自己实现的
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="注解" scheme="http://zkalan.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>spring中的注解</title>
    <link href="http://zkalan.com/spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3.html"/>
    <id>http://zkalan.com/spring中的注解.html</id>
    <published>2019-10-30T09:16:45.000Z</published>
    <updated>2019-11-01T03:15:37.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用于创建对象的注解"><a href="#用于创建对象的注解" class="headerlink" title="用于创建对象的注解"></a>用于创建对象的注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@component</span>(value=<span class="string">"accountService"</span>)</span><br><span class="line">puclic <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>作用：用于当前类对象存入spring容器中</li><li>属性value用于指定bean的id，默认为当前类名，并且首字母小写</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.package"</span>&gt;</span><span class="tag">&lt;/<span class="name">content:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Controller（表现层）、Service（业务层）、Repository（持久层）作用和属性与component完全一致，区分的意义在于使得三层对象更加清晰。</p><h3 id="用于注入数据的注解"><a href="#用于注入数据的注解" class="headerlink" title="用于注入数据的注解"></a>用于注入数据的注解</h3><p>@Autowired</p><ul><li>作用：自动按照类型注入。只要容器中有唯一的bean对象类型和要注入的变量类型匹配；可以是变量上注解，也可以是方法上；如果ioc容器中没有任何bean和要注入的类型匹配，则报错；如果ioc容器中有多个类型匹配时，变量名和某个bean的id匹配时也可注入成功；</li><li>在使用注解注入时，set方法是不必要的</li></ul><p>@Qualifier</p><ul><li>作用：在按照类型注入的基础上再按照名称注入，它在给类成员变量注入时不能单独使用，要和autowired组合；但是在给成员方法参数进行注入时可以单独使用；</li><li>属性value用于指定注入的bean的id</li></ul><p>@Resource</p><ul><li>作用：直接按照bean的id注入，可以单独使用</li><li>属性name用于指定bean的id<br>以上三个注解只能注入其他bean类型数据，而基本类型和String类型无法使用上述注解实现，另外，集合类型的注入只能通过xml来实现。</li></ul><p>@Value</p><ul><li>作用：用于注入基本数据类型和String类型的数据</li><li>属性value用于指定数据的值，它可以使用spring中的SpEL，也就是spring的el表达式，SpEL的写法：${表达式}</li></ul><h3 id="用于改变作用范围的注解"><a href="#用于改变作用范围的注解" class="headerlink" title="用于改变作用范围的注解"></a>用于改变作用范围的注解</h3><p>@Scope</p><ul><li>作用：用于指定bean的作用范围</li><li>属性value指定范围的取值，singleton、prototype</li></ul><h3 id="和生命周期有关的注解"><a href="#和生命周期有关的注解" class="headerlink" title="和生命周期有关的注解"></a>和生命周期有关的注解</h3><p>@PreDestroy：指定销毁方法<br>@PostConstruct：指定初始化方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用于创建对象的注解&quot;&gt;&lt;a href=&quot;#用于创建对象的注解&quot; class=&quot;headerlink&quot; title=&quot;用于创建对象的注解&quot;&gt;&lt;/a&gt;用于创建对象的注解&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="注解" scheme="http://zkalan.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>spring中的依赖注入</title>
    <link href="http://zkalan.com/spring%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html"/>
    <id>http://zkalan.com/spring中的依赖注入.html</id>
    <published>2019-10-30T07:22:34.000Z</published>
    <updated>2019-11-01T09:18:10.443Z</updated>
    
    <content type="html"><![CDATA[<p><strong>依赖注入Dependency Injection；IOC的作用：降低程序之间的耦合、依赖关系；依赖关系的管理都交给spring维护；在当前类中需要的其他类的对象，由spring提供，只需要在配置文件中说明；依赖关系的维护称之为依赖注入。</strong></p><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>能够注入的数据有三类</p><ul><li>基本数据类型和String</li><li>其他bean类型（在配置文件或注解配置过的bean）</li><li>复杂类型/集合类型<br>注入的方式，三种</li><li>使用构造函数提供</li><li>使用set方法提供</li><li>使用注解提供</li></ul><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><p>使用的标签：constructor-arg<br>标签出现的位置：bean标签的内部</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签中的属性：</p><ul><li>type：用于指定要注入的构造函数参数列表中数据的数据类型</li><li>index：用于指定要注入的数据在构造函数参数列表中的索引值，从零开始</li><li>name：指定构造函数中的形式参数名称</li><li>value：用于提供基本数据类型和String类型的数据</li><li>ref：用于指定其他的bean类型数据，必须是在spring核心容器中出现过的bean对象</li></ul><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>在获取bean对象时，注入数据是必须的操作，否则无法创建对象</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>改变了bean对象的实例化方式，使我们在创建对象时必须提供指定的数据</p><h3 id="set方法注入-更常用"><a href="#set方法注入-更常用" class="headerlink" title="set方法注入(更常用)"></a>set方法注入(更常用)</h3><p>涉及的标签：property<br>出现的位置：bean标签内部<br>标签的属性</p><ul><li>name：用于指定注入时使用的set方法名字，改名字是set方法去掉set后余下的部分，并且首字母小写</li><li>value：用于提供基本类型和String类型的数据</li><li>ref：用于指定其他的bean数据类型，必须是在spring核心容器中出现过的bean对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂类型注入"><a href="#复杂类型注入" class="headerlink" title="复杂类型注入"></a>复杂类型注入</h3><p>用于给list结构集合注入使用标签list、array、set，可通用；<br>用于给map结构集合注入使用标签map、props，可通用；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mystring"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myarray"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myset"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mymap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myprop"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"a"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;依赖注入Dependency Injection；IOC的作用：降低程序之间的耦合、依赖关系；依赖关系的管理都交给spring维护；在当前类中需要的其他类的对象，由spring提供，只需要在配置文件中说明；依赖关系的维护称之为依赖注入。&lt;/strong&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="依赖注入" scheme="http://zkalan.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>bean的笔记</title>
    <link href="http://zkalan.com/bean%E7%9A%84%E7%AC%94%E8%AE%B0.html"/>
    <id>http://zkalan.com/bean的笔记.html</id>
    <published>2019-10-30T03:32:11.000Z</published>
    <updated>2019-12-10T09:11:17.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring对bean的管理细节"><a href="#spring对bean的管理细节" class="headerlink" title="spring对bean的管理细节"></a>spring对bean的管理细节</h2><h3 id="创建bean的三种方式"><a href="#创建bean的三种方式" class="headerlink" title="创建bean的三种方式"></a>创建bean的三种方式</h3><h4 id="使用默认构造函数创建"><a href="#使用默认构造函数创建" class="headerlink" title="使用默认构造函数创建"></a>使用默认构造函数创建</h4><p>在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的是默认构造函数创建对象，此时必须存在无参数构造函数；</p><h4 id="使用普通工厂中的方法创建对象，并存入spring容器"><a href="#使用普通工厂中的方法创建对象，并存入spring容器" class="headerlink" title="使用普通工厂中的方法创建对象，并存入spring容器"></a>使用普通工厂中的方法创建对象，并存入spring容器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用工厂中的静态方法创建对象"><a href="#使用工厂中的静态方法创建对象" class="headerlink" title="使用工厂中的静态方法创建对象"></a>使用工厂中的静态方法创建对象</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.factory.StaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"staticgetAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="bean对象的作用范围"><a href="#bean对象的作用范围" class="headerlink" title="bean对象的作用范围"></a>bean对象的作用范围</h3><h4 id="bean标签的scope属性"><a href="#bean标签的scope属性" class="headerlink" title="bean标签的scope属性"></a>bean标签的scope属性</h4><ul><li>作用：用于指定bean的作用范围</li><li>取值：<ul><li>singleton：单例，默认值</li><li>prototype：多例</li><li>request：作用于web应用的请求范围</li><li>session：作用于web应用的会话范围</li><li>global-session：作用于集群的会话范围</li></ul></li></ul><h3 id="bean对象的生命周期"><a href="#bean对象的生命周期" class="headerlink" title="bean对象的生命周期"></a>bean对象的生命周期</h3><ol><li>单例对象：容器创建时对象创建，声明周期和容器相同；</li><li>多例对象：使用时spring框架创建对象，对象回收由JVM负责；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spring对bean的管理细节&quot;&gt;&lt;a href=&quot;#spring对bean的管理细节&quot; class=&quot;headerlink&quot; title=&quot;spring对bean的管理细节&quot;&gt;&lt;/a&gt;spring对bean的管理细节&lt;/h2&gt;&lt;h3 id=&quot;创建bean的三种
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://zkalan.com/categories/Spring/"/>
    
    
      <category term="spring" scheme="http://zkalan.com/tags/spring/"/>
    
      <category term="bean" scheme="http://zkalan.com/tags/bean/"/>
    
  </entry>
  
</feed>
